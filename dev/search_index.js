var documenterSearchIndex = {"docs":
[{"location":"#ClusteredLowRankSolver.jl","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.jl","text":"","category":"section"},{"location":"","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.jl","text":"ClusteredLowRankSolver.jl provides a primal-dual interior point method for solving clustered low-rank semidefinite programs. This can primarily be used for (semidefinite) programs with polynomial inequality constraints, which can be rewritten in terms of sum-of-squares polynomials. See the manual for a more detailed description of the problems and the usage of the solver.","category":"page"},{"location":"","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.jl","text":"Modules = [ClusteredLowRankSolver]","category":"page"},{"location":"#ClusteredLowRankSolver.Block","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.Block","text":"Block(l::Any[, r::Int, s::Int])\n\nSpecifies a block corresponding to the positive semidefinite variable l.\n\nSpecifying r,s makes the Block correspond to the r,s subblock of the variable l.\n\n\n\n\n\n","category":"type"},{"location":"#ClusteredLowRankSolver.ClusteredLowRankSDP","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.ClusteredLowRankSDP","text":"ClusteredLowRankSDP(sos::LowRankSOSProblem[, as_free])\n\nDefine a ClusteredLowRankSDP based on the LowRankSOSProblem sos.\n\nThe PSD variables defined by the keys as_free will be modelled as extra free variables, with extra constraints to ensure that they are equal to the entries of the PSD variables. Keyword arguments:     prec (default: precision(BigFloat)) - the precision of the result     verbose (default: false) -  print progress to the standard output\n\n\n\n\n\n","category":"type"},{"location":"#ClusteredLowRankSolver.Constraint","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.Constraint","text":"Constraint(constant, matrixcoeff, freecoeff, samples[, scalings])\n\nModels a polynomial constaint of the form     constant(x) = ∑block < block, matrixcoeffblock > + ∑freevar freecoefffreevar*freevar sampled on the elements of samples.\n\nArguments:     constant::MPolyElem     matrixcoeff::Dict(Block, LowRankMatPol)     freecoeff::Dict(Any, MPolyElem)     samples::Vector{Vector}     scalings::Vector\n\n\n\n\n\n","category":"type"},{"location":"#ClusteredLowRankSolver.LowRankMatPol","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.LowRankMatPol","text":"LowRankMat(eigenvalues::Vector, rightevs::Vector{Vector}[, leftevs::Vector{Vector}])\n\nThe matrix ∑_i eigenvalues[i]rightevs[i]leftevs[i]'.\n\nIf leftevs is not specified, use leftevs = rightevs. The elements of the Vectors are\n\n\n\n\n\n","category":"type"},{"location":"#ClusteredLowRankSolver.Objective","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.Objective","text":"Objective(constant, matrixcoeff::Dict{Block, Matrix}, freecoeff::Dict)\n\nThe objective for the LowRankSOSProblem\n\n\n\n\n\n","category":"type"},{"location":"#ClusteredLowRankSolver.approximatefekete-Tuple{Any, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.approximatefekete","text":"approximatefekete(basis, samples) -> basis, samples\n\nCompute approximate fekete points based on samples and a corresponding orthogonal basis.\n\nThis preserves a degree ordering of basis if present.\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.calculate_res_d!-NTuple{6, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.calculate_res_d!","text":"Compute the dual residue d = c - <A_*, Y> - By\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.check_pd_feasibility-NTuple{4, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.check_pd_feasibility","text":"Check primal and dual feasibility\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.compute_S_integrated!-NTuple{11, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.compute_S_integrated!","text":"Compute S, integrated with the precomputing of the bilinear pairings\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.compute_T_decomposition!-NTuple{14, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.compute_T_decomposition!","text":"Compute the decomposition of [S B; B^T 0]\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.compute_dual_error-Tuple{Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.compute_dual_error","text":"Compute the dual error\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.compute_dual_objective-Tuple{Any, Any, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.compute_dual_objective","text":"Compute the dual objective <C,Y> + <b,y> + constant\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.compute_duality_gap-NTuple{4, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.compute_duality_gap","text":"Compute the duality gap (primalobj - dualobj)/max{1, |primalobj+dualobj|}\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.compute_error-Tuple{Arblib.ArbRefMatrix}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.compute_error","text":"Compute the error (max abs(d_ij)) of an ArbMatrix\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.compute_error-Tuple{BlockDiagonals.BlockDiagonal}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.compute_error","text":"Compute the error (max abs (P_ij)) of a blockdiagonal matrix\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.compute_primal_error-Tuple{Any, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.compute_primal_error","text":"Compute the primal error\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.compute_primal_objective-Tuple{Any, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.compute_primal_objective","text":"Compute the primal objective <c, x> + constant\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.compute_residual_R!-NTuple{5, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.compute_residual_R!","text":"Compute the residual R, with or without second order term \n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.compute_residuals!-NTuple{11, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.compute_residuals!","text":"Compute the residuals P,p and d.\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.compute_search_direction!-NTuple{17, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.compute_search_direction!","text":"Compute the search directions, using a precomputed decomposition\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.compute_step_length-Tuple{BlockDiagonals.BlockDiagonal, BlockDiagonals.BlockDiagonal, Any, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.compute_step_length","text":"Compute the step length min(γ α(M,dM), 1), where α is the maximum number step to which keeps M+α(M,dM) dM positive semidefinite\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.compute_weighted_A!-NTuple{4, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.compute_weighted_A!","text":"Set initialmatrix to ∑i ai Ai\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.distribute_weights_swapping-Tuple{Any, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.distribute_weights_swapping","text":"Distribute the weights over n (about) equal-sized bins by swapping between bins with high total weight and low total weight.\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.dot_c-Tuple{Any, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.dot_c","text":"Compute <c,x> where c is distributed over constraints\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.solvesdp","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.solvesdp","text":"solvesdp(sdp; kwargs...)\n\nSolve the clustered SDP with low-rank constraint matrices.\n\nSolve the following sdp:     'max/min ∑j <C^j, Y^j> + b^T y     s.t.    <A^j,Y^j> + B^j y = c^j             Y^j ⪰ 0' where we optimize over the free variables 'y' and the PSD block matrices 'Y^j = diag(Y^{j,1}, ..., Y^{j,Lj})', and '<A^j, Y^j> = (<Ap^j, Y^j>){p=1,...,Pj}'. The matrices A^jp have the same block structure as Y^j. Every A^{j,l} can have several equalsized blocks A^{j,l}[r,s]. The smallest blocks have a low rank structure.\n\nImportant keyword arguments which are not clear from the name:     - gamma: the step length reduction; a maximum step length of α reduces to a step length of max(gammaα,1)     - beta(in)feasible: the amount mu is tried to be reduced by in each iteration, for (in)feasible solutions     - omegap/d: the starting matrix variable for the primal/dual is omega_p/dI\n\n\n\n\n\n","category":"function"},{"location":"#ClusteredLowRankSolver.terminate-NTuple{8, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.terminate","text":"Determine whether the main loop should terminate or not\n\n\n\n\n\n","category":"method"},{"location":"#ClusteredLowRankSolver.trace_A-Tuple{Any, BlockDiagonals.BlockDiagonal, Any, Any}","page":"ClusteredLowRankSolver.jl","title":"ClusteredLowRankSolver.trace_A","text":"Compute the vector <A*,Z> = Tr(A* Z) for one or all constraints\n\n\n\n\n\n","category":"method"}]
}
